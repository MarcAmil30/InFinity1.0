### calculate LinF9 score of bridge waters in pdb structure ###

import sys
import os
import re
import numpy as np
from scipy.spatial import distance
import pandas as pd

Smina = '[USER_DIR]/InFinity/Delta_LinF9_XGB/software/smina.static' ## set the smina path

def get_protein_file(infile):
    '''
    Remove water molecules in protein structure

    '''
    outfile = '%s_noh.pdb'%infile.split('.')[0]
    
    f1 = open(infile,'r')
    f2 = open(outfile,'w')
    for line in f1.readlines():
        if line.startswith(('ATOM','HETATM')) and line[17:20] not in ['HOH','WAT','TIP']:
            f2.write(line)
    f2.close()
    f1.close()
    
    return outfile

def affinity_match(signal):
    '''
    Match the pattern of affinity generated by LinF9 --score_only
    
    '''
    match = re.search(r'Affinity:\s(\S+) ', signal)

    if match:
        return match.group(1)
    else:
        return 'None'


def get_prot_Pcoord(pro_name):
    '''
    Get protein polar coordinates
    '''
    Atomic = ['N','O','S','P']
    f1 = open(pro_name, 'r')
    List = []
    for line in f1.readlines():
        if line.startswith(('ATOM', 'HETATM')) and line[17:20] not in ['HOH','WAT','TIP'] and line[77:78] in Atomic:
            coord_x = float(line[30:38])
            coord_y = float(line[38:46])
            coord_z = float(line[46:54])
            coord = np.array([coord_x, coord_y, coord_z])
            List.append(coord)
    List = np.array(List)
    
    return List

def get_lig_Pcoord(lig_name):
    '''
    Get lig polar coordinates
    '''
    Atomic = ['N','O','S','P']
    f1 = open(lig_name, 'r')
    List = []
    for line in f1.readlines():
        if line.startswith(('ATOM', 'HETATM')) and line[77:78] in Atomic:
            coord_x = float(line[30:38])
            coord_y = float(line[38:46])
            coord_z = float(line[46:54])
            coord = np.array([coord_x, coord_y, coord_z])
            List.append(coord)
    List = np.array(List)
    
    return List

def get_wat_id(filename, prot_Plist, lig_Plist, cutoff=3.5):
    '''
    Get water id (residue_chain_resnum), for example: 'HOH A2001'
    
    '''
    f_in = open(filename, 'r')
    wat_id = [] # water id
    wat_b = []  # water bfactor
    coord_x = []
    coord_y = []
    coord_z = []
    wat_list = []  ## water coordinates x,y,z
    
    for i in f_in.readlines():
        if i.startswith(('HETATM', 'ATOM')) and i[17:20] == 'HOH':
            wat_id.append(i[17:26])
            wat_b.append(float(i[60:66]))
            coord_x.append(float(i[30:38]))
            coord_y.append(float(i[38:46]))
            coord_z.append(float(i[46:54]))
            coord = np.array([float(i[30:38]), float(i[38:46]), float(i[46:54])])
            wat_list.append(coord)
    f_in.close()
    wat_list = np.array(wat_list)

    if len(wat_id) > 0:
        if len(prot_Plist) > 0:
            distP = distance.cdist(wat_list, prot_Plist, 'euclidean')
            distP_min = np.min(distP, axis=1)
        else:
            distP_min = [10]*len(wat_id)

        if len(lig_Plist) > 0:
            distL = distance.cdist(wat_list, lig_Plist, 'euclidean')
            distL_min = np.min(distL, axis=1)
        else:
            distL_min = [10]*len(wat_id)
    else:
        distP_min = []
        distL_min = []
    
    df = pd.DataFrame(list(zip(wat_id, wat_b, coord_x, coord_y, coord_z, distP_min, distL_min)), columns = ['Wat_id', 'Bfactor', 'coord_x', 'coord_y', 'coord_z', 'distP_min', 'distL_min'])
    df = df.loc[(df['distP_min']<=cutoff)&(df['distP_min']>=2)&(df['distL_min']<=cutoff)&(df['distL_min']>=2)]
    df = df.round({'distP_min':3, 'distL_min':3})
    
    return df


def calculate_score(filename, Pname, Lname, wat_id, smina):
    '''
    calculate LinF9 score of water in the environment 
    
    '''
    wat_test = 'test_wat.pdb'

    # get water ligand for docking
    os.system("grep '%s' %s > %s"%(wat_id, filename, wat_test))
    #perform LinF9 --score_only
    signal_P = os.popen('%s --seed 1 -r %s -l %s --score_only --scoring Lin_F9 '%(smina, Pname, wat_test)).read()
    score_P = affinity_match(signal_P)
    signal_L = os.popen('%s --seed 1 -r %s -l %s --score_only --scoring Lin_F9 '%(smina, Lname, wat_test)).read()
    score_L = affinity_match(signal_L) 

    os.system('rm %s'%(wat_test))

    return float(score_P), float(score_L)

def BW_features(df):
    '''
    Input is the csv file with water information
    '''
    df = df.drop_duplicates('Wat_id')
    Nbw = len(df)
    Epw = round(df['P_score'].sum()*(-0.73349), 3)
    Elw = round(df['L_score'].sum()*(-0.73349), 3)

    return Nbw, Epw, Elw
    
def Check_bridge_water(pro, lig, cutoff=3.5):
    prot_Pcoords = get_prot_Pcoord(pro)
    lig_Pcoords = get_lig_Pcoord(lig)
    df = get_wat_id(pro, prot_Pcoords, lig_Pcoords, cutoff=cutoff)
    return df

def Sum_score(pro, lig, df, smina):
    scoreP_ = []
    scoreL_ = []
    proname = get_protein_file(pro)

    for i in df['Wat_id'].tolist():
        scoreP, scoreL = calculate_score(pro, proname, lig, i, smina)
        scoreP_.append(scoreP)
        scoreL_.append(scoreL)

    df['P_score'] = pd.Series(scoreP_, index=df.index)
    df['L_score'] = pd.Series(scoreL_, index=df.index)
    df  = df.loc[(df['P_score']<0)&(df['L_score']<0)]
    os.system('rm %s'%proname)
    Nbw, Epw, Elw = BW_features(df)

    return Nbw, Epw, Elw

def main():
    args = sys.argv[1:]

    if not args:
        print ('usage: python calc_bridge_wat.py pro lig outfile fn')

        sys.exit(1)

    elif sys.argv[1] == '--help':
        print ('usage: python calc_bridge_wat.py pro lig outfile fn')

        sys.exit(1)

    elif len(args)==4:

        pro = sys.argv[1]
        lig = sys.argv[2]
        outfile = sys.argv[3]
        fn = sys.argv[4]
        
        df = Check_bridge_water(pro, lig, cutoff=3.5)  ## distance cutoff

        out = open(outfile, "w")
        if len(df) == 0:
            out.write(fn+","+"0,0,0"+"\n")
            out.close()
            
        else:
            Nbw, Epw, Elw = Sum_score(pro, lig, df, smina)
            out.write(fn+","+str(round(Nbw, 1))+","+str(round(Epw, 3))+","+str(round(Elw, 3))+"\n")
            out.close()
            
        
    else:
        sys.exit(1)

if __name__ == '__main__':
    main()
            
            
